import * as IndexTypes from '../types/indexApi';
import * as ReactonTypes from '../types/reactionApi';
import { AsyncResult, UserId } from '../types/common';
export interface Contact {
	/**
	 * Gets the blocklist.
	 *
	 * ```typescript
	 * connection.getBlocklist()
	 * ```
	 */
	getBlocklist(): Promise<AsyncResult<UserId[]>>;

	/**
	 * Gets the contact list.
	 *
	 * ```typescript
	 * connection.getContacts()
	 * ```
	 */
	getContacts(): Promise<AsyncResult<UserId[]>>;

	/**
	 * Uploads the token to the server. This method is used when the SDK is used on a native client on which a third-party push service is to be integrated.
	 *
	 * ```typescript
	 * connection.uploadPushToken({deviceId: 'deviceId', deviceToken: 'deviceToken', notifierName: 'notifierName'})
	 * ```
	 */
	uploadPushToken(params: {
		/** The device ID that identifies the device. Custom device IDs are allowed. */
		deviceId: string;
		/** The push token, which identifies a device during message push. Custom push tokens are allowed.*/
		deviceToken: string;
		/** The app ID for the push service, which is the senderID for Firebase Cloud Messaging (FCM) and "appId+#+AppKey" for the vivo push service. */
		notifierName: string;
	}): Promise<AsyncResult<IndexTypes.UploadTokenResult>>;

	/**
	 * Gets the conversation list.
	 *
	 * ```typescript
	 * connection.getConversationlist()
	 * ```
	 */
	getConversationlist(): Promise<AsyncResult<IndexTypes.SessionInfo[]>>;

	/**
	 * Deletes the conversation.
	 *
	 * ```typescript
	 * connection.deleteConversation()
	 * ```
	 */
	deleteConversation(params: {
		/** The conversation ID: the peer's user ID or group ID. */
		channel: string;
		/** The conversation type.
		 * - `singleChat`: one-to-one chat;
		 * - `groupChat`: group chat.
		 */
		chatType: 'singleChat' | 'groupChat';
		/** Whether to delete server roaming messages during conversation deletion.
		 * - `true`: Yes;
		 * - `false`: No.
		 */
		deleteRoam: boolean;
	}): Promise<AsyncResult<IndexTypes.DeleteSessionResult>>;

	/**
	 * Modifies the user's attributes.
	 *
	 * ```typescript
	 * connection.updateUserInfo({nickname: 'Tom', avatarurl: 'avatarurl', mail: 'abc@gmail,com', ext: JSON.stringify({hobby: 'football'})})
	 *
	 * connection.updateUserInfo('nickname', 'Tom')
	 * ```
	 */
	updateOwnUserInfo(
		params: IndexTypes.UpdateOwnUserInfoParams | IndexTypes.ConfigurableKey,
		value?: any
	): Promise<AsyncResult<IndexTypes.UpdateOwnUserInfoParams>>;

	/**
	 * Queries the user attributes.
	 *
	 * ```typescript
	 * connection.fetchUserInfoById('user1') | fetchUserInfoById(['user1', 'user2'])
	 * ```
	 */
	fetchUserInfoById(
		/** The array of IDs of users or user ID to query.  */
		userId: UserId | UserId[],
		/** User properties to query. If the parameter is blank, query all. */
		properties?: IndexTypes.ConfigurableKey[] | IndexTypes.ConfigurableKey
	): Promise<AsyncResult<IndexTypes.UpdateOwnUserInfoParams>>;

	/**
	 * Changes the nickname shown when the message push notification is received. This nickname is specified during user registration and it's not the same as the nickname attribute of the user.
	 *
	 * ```typescript
	 * connection.updateCurrentUserNick('Tom')
	 * ```
	 */
	updateCurrentUserNick(
		/** The nickname shown when a message push notification is received. */
		nick: string
	): Promise<AsyncResult<IndexTypes.BaseUserInfo[]>>;

	/**
	 * Gets the message history.
	 *
	 * ```typescript
	 * connection.getHistoryMessages({targetId:'user1',chatType:'groupChat', pageSize: 20})
	 * ```
	 */
	getHistoryMessages(options: {
		/** The user ID of the other party or the group ID. */
		targetId: string;
		/** The starting message ID for this query. The default value is -1, which means to start retrieving from the latest message. */
		cursor?: number | string | null;
		/** The number of messages to retrieve each time. The default value is 20,The maximum value is 50. */
		pageSize?: number;
		/** The chat type:
		 * - `singleChat`: one-to-one chat;
		 * - `groupChat`: group chat;
		 * - `chatRoom`: chat room.
		 * - (Default)`singleChat`: No.
		 */
		chatType?: 'singleChat' | 'groupChat' | 'chatRoom';
		/** Whether to select pull history messages in positive order(Pull message from the oldest to the latest).
		 * - `up`: means searching from the newer messages to the older messages.
		 * - `down`: means searching from the older messages to the newer messages.
		 * - (Default)`up`.
		 */
		searchDirection?: string;
	}): Promise<IndexTypes.HistoryMessages>;

	/**
	 * Adds a friend.
	 *
	 * ```typescript
	 * connection.addContact('user1', 'I am Bob')
	 * ```
	 */
	addContact(
		/** The user ID of the other party. */
		to: string,
		/** The validation message. */
		message?: string
	): void;

	/**
	 * Deletes the contact.
	 *
	 * ```typescript
	 * connection.deleteContact('user1')
	 * ```
	 */
	deleteContact(
		/** The user ID of the other party. */
		to: string
	): void;

	/**
	 * Accepts a friend request.
	 *
	 * ```typescript
	 * connection.acceptContactInvite('user1')
	 * ```
	 */
	acceptContactInvite(
		/** The user ID of the other party. */
		to: string
	): void;

	/**
	 * Declines a friend request.
	 *
	 * ```typescript
	 * connection.declineContactInvite('user1')
	 * ```
	 */
	declineContactInvite(
		/** The user ID of the other party. */
		to: string
	): void;

	/**
	 * Adds a contact to the blocklist.
	 *
	 * ```typescript
	 * connection.addUsersToBlocklist({name: 'user1'})
	 * ```
	 */
	addUsersToBlocklist(options: {
		/** The user ID. You can type a specific user ID to add a single user to the blocklist or type an array of user IDs, like ["user1","user2"], to add multiple users. */
		name: UserId | UserId[];
	}): void;

	/**
	 *
	 * Removes contacts from the blocklist.
	 *
	 * ```typescript
	 * connection.removeUserFromBlocklist({name: 'user1'})
	 * ```
	 */
	removeUserFromBlocklist(options: {
		/** The user ID. You can type a specific user ID to remove a single user from the blocklist or type an array of user IDs, like ["user1","user2"], to remove multiple users. */
		name: UserId | UserId[];
	}): void;

	/**
	 * Recalls a message.
	 *
	 * ```typescript
	 * connection.recallMessage({mid: 'messageId', to: 'user1', type: 'singleChat'})
	 * ```
	 */
	recallMessage(option: {
		/** The ID of the message to be recalled. */
		mid: string;
		/** The recipient of the message. */
		to: UserId;
		/** The chat type:
		 * - `singleChat`: one-to-one chat;
		 * - `groupchat`: group chat;
		 * - `chatroom`: chat room.
		 */
		chatType?: 'singleChat' | 'groupChat' | 'chatRoom';
		/** Is it a message in the thread. */
		isChatThread?: boolean;
	}): Promise<IndexTypes.SendMsgResult>;

	/**
	 * Adds a reaction to the message.
	 *
	 * ```typescript
	 * connection.addReaction({messageId: 'messageId', action: 'action'})
	 * ```
	 */
	addReaction(params: {
		/** The message ID. */
		messageId: string;
		/** The reaction to be added to the message. The length is limited to 128 characters. */
		reaction: string;
	}): Promise<void>;

	/**
	 * Removes a reaction from a message.
	 *
	 * ```typescript
	 * connection.deleteReaction({reactionId: 'reactionId'})
	 * ```
	 */
	deleteReaction(params: {
		/** The message reaction to delete.  */
		reaction: string;
		/** The message ID. */
		messageId: string;
	}): Promise<void>;

	/**
	 * Gets the reaction list for the message.
	 *
	 * ```typescript
	 * connection.getReactionlist({chatType: 'chatType', messageId: 'messageId'})
	 * ```
	 */
	getReactionList(params: {
		/** The conversation type:
		 * - singleChat;
		 * - groupChat;
		 */
		chatType: 'singleChat' | 'groupChat';
		/** The message ID. */
		messageId: string | Array<string>;
		/** The group ID. */
		groupId?: string;
	}): Promise<AsyncResult<ReactonTypes.GetReactionListResult[]>>;

	/**
	 * Gets the details of a reaction.
	 *
	 * ```typescript
	 * getReactionDetail({messageId: 'messageId', reaction: 'reaction', cursor: '', pageSize: 20})
	 * ```
	 */
	getReactionDetail(params: {
		/** The message ID. */
		messageId: string;
		/** The reactions to retrieve. */
		reaction: string;
		/** The cursor that specifies where to start to get data. If there will be data on the next page, this method will return the value of this field to indicate the position to start to get data of the next page. If it is null, the data of the first page will be retrieved.*/
		cursor?: string;
		/** The number of reactions per page. The default value is 20, and the maximum value is 100. */
		pageSize?: number;
	}): Promise<AsyncResult<ReactonTypes.GetReactionDetailResult>>;

	/**
	 * Reports a message.
	 *
	 * ```typescript
	 * reportMessage()
	 * ```
	 */
	reportMessage(params: {
		/** The type of report. */
		reportType: string;
		/** The reason for reporting. */
		reportReason: string;
		/** ID of the message to be reported. */
		messageId: string;
	}): Promise<void>;

	/**
	 * Delete roaming messages.
	 *
	 * ```typescript
	 * connection.removeHistoryMessages({targetId: 'userId', chatType: 'singleChat', beforeTimeStamp: Date.now()})
	 *
	 * connection.removeHistoryMessages({targetId: 'userId', chatType: 'singleChat', messageIds: ['messageId']})
	 * ```
	 */
	removeHistoryMessages(options: {
		/** The ID of the peer user or group ID. */
		targetId: string;
		/**
		 * The conversation type:
		 * - `singleChat`: one-to-one chat;
		 * - `groupChat`: group chat.
		 */
		chatType: 'singleChat' | 'groupChat';
		/** The ID list of messages to be deleted. A maximum of 20 message IDs can be passed. */
		messageIds?: Array<string>;
		/** The starting timestamp for message deletion. Messages with the timestamp before the specified one will be deleted. */
		beforeTimeStamp?: number;
	}): Promise<void>;
}
